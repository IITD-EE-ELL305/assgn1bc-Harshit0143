[
"00000 1 0111 0111 00 0000000000001111",
"01111 1 0111 0000 0000 00000000000100",
"01110 1 0011 0000 0000 00000000000100",
"00000 1 0011 0011 0000 00000000001011",
"00000 1 0001 0001 00 0000000000001010",
"00101 0 0000 0001 00 1000000000000000",
"10000 1 0000 0000 00 0000000000001000",
"00000 1 0001 0001 00 0000000000100010",
"00000 1 0001 0001 00 0000000000001010",
"01101 0 0000 0000 00 0000000000000000",
"00000 1 0010 0010 00 0000000000001010",
"01101 0 0000 0000 00 0000000000000000",
"00101 0 0000 0001 00 1000000000000000",
"10000 1 0000 0000 00 0000000000001000",
"01101 0 0000 0000 00 0000000000000000",
"00000 1 0001 0001 00 0000000000100010",
"00000 1 0001 0001 00 0000000000001010",
"00000 1 0010 0010 00 0000000000001010",
"00101 0 0000 0001 00 1000000000000000",
"10000 1 0000 0000 00 1111111111111000",
"00000 1 0010 0010 00 0000000000100010"]




















r1 += 10
r2 += 10
cmp r1 r2 // True

r2 += 34
[
"00000 1 0111 0111 00 0000000000001111", r7 += 15
"01111 1 0111 0000 0000 00000000000101", store r7 into 5[r0]
"01110 1 0011 0000 0000 00000000000101", load into r3 5[r0]
"00000 1 0011 0011 0000 00000000001011", r3 += 11
"00000 1 0001 0001 00 0000000000001010", r1 += 10
"00101 0 0000 0001 00 1000000000000000", cmp r1 r2 // Flase 
"10000 1 0000 0000 00 0000000000001000", beq : 8
"00000 1 0001 0001 00 0000000000100010", r1 += 34
"01101 0 0000 0000 00 0000000000000000", nop
"00000 1 0010 0010 00 0000000000101100", r2 += 44
"01101 0 0000 0000 00 0000000000000000", nop
"00101 0 0000 0001 00 1000000000000000", cmp r1 r2 // True
"10000 1 0000 0000 00 0000000000001000", beq : 8 
"01101 0 0000 0000 00 0000000000000000", nop
"10000 1 0000 0000 00 1111111111111000", beq : -8
]



[
"00000 1 0111 0111 00 0000000000001111", 
"01111 1 0111 0000 0000 00000000000101", 
"01110 1 0011 0000 0000 00000000000101", 
"00000 1 0011 0011 0000 00000000001011",
"00000 1 0001 0001 00 0000000000001010", 
"00101 0 0000 0001 00 1000000000000000", 
"10000 1 0000 0000 00 0000000000001000", 
"00000 1 0001 0001 00 0000000000100010", 
"01101 0 0000 0000 00 0000000000000000", 
"00000 1 0010 0010 00 0000000000101100",
"01101 0 0000 0000 00 0000000000000000", 
"00101 0 0000 0001 00 1000000000000000", 
"10000 1 0000 0000 00 0000000000001000", 
"01101 0 0000 0000 00 0000000000000000",
"10000 1 0000 0000 00 1111111111111000",
]




### call , ret 

10011 1 0000 0000 000000000000011000 0
10011 1 0000 0000 000000000000011000 4
10011 1 0000 0000 000000000000011000 8
00000 1 0001 0001 000000000000010011 12
00000 1 0010 0010 000000000000010111 16
11111 0 0000 0000 000000000000000000 20
00001 1 0001 0001 000000000000001010 24
00000 1 0010 0010 000000000000010100 28
10100 0 0000 0000 000000000000000000 32

call fun.
call fun.
call fun.
r1 += 19
r2 += 23
halt
fun.
r1 -= 10
r2 += 20 
ret 
"""

"10011 1 0000 0000 000000000000011000",
"10011 1 0000 0000 000000000000011000",
"10011 1 0000 0000 000000000000011000",
"00000 1 0001 0001 000000000000010011",
"00000 1 0010 0010 000000000000010111",
"11111 0 0000 0000 000000000000000000",
"00001 1 0001 0001 000000000000001010",
"00000 1 0010 0010 000000000000010100", 
"10100 0 0000 0000 000000000000000000"


"""

[ ] Load two numbers into r1 and r2
  - [ ] Add the two numbers and store result in r3
  - [ ] Compare that with your 'manual' addition (supplied as an _imm_ to _cmp__
  - [ ] If result is correct write 0x0 to r4 and skip next instruction; else branch to the next instruction and write 0xFFFFFFFF (all 1s) to r4
  - [ ] Call a new function that stores the value from r4 to the data memory
  - [ ] Return from the call
  - [ ] Load value from data memory to r5
  - [ ] Halt the CPU
  - [ ] Check values of all relevant registers to ensure that the CPU is working as expected
00000 1 0001 0001 00 0000000000000101 // 0: r1 += 5
00000 1 0010 0010 00 0000000000001011 // 4: r2 += 11
00000 0 0011 0001 00 1000000000000000 // 8: r3 = r1 + r2
00101 1 0000 0011 00 0000000000010000 // 12: cmp r3 16
10000 1 0000 0000 00 0000000000001000 // 16: beq 8
00000 1 0100 0100 00 1111111111111111 // 20: r4 += -1
00000 1 0100 0100 00 0000000000001111 // 24: r4 += 15
10011 1 0000 0000 00 0000000000101100 // 28: call .boo
01110 1 0101 0000 00 0000000000000000 // 32: load memory[0] into r5, as r0 = 0
00000 1 0101 0101 00 0000000000000000 // 36: r5 += 0
11111 0 0000 0000 00 0000000000000000 // 40: halt
01111 1 0100 0000 00 0000000000000000 // 44: store: value in r0 = 0 , imm = 0 so stored in memory[0]
10100 0 0000 0000 00 0000000000000000 // 48: ret
"""




r1 += 19
r2 += 23
r2 -= 5
r3 = r1 and r2
r3 = r3 and 5
r3 = r1 or r2
r3 r3 or 5
r3 = r1 xor r2
r3 = r3 xor 5
"00000 1 0001 0001 000000000000010011",
"00000 1 0010 0010 000000000000010111",
"00001 1 0010 0010 000000000000000101",
"00110 0 0011 0001 001000000000000000",
"00110 1 0011 0011 000000000000000101",
"00111 0 0011 0001 001000000000000000",
"00111 1 0011 0011 000000000000000101",
"11110 0 0011 0001 001000000000000000",
"11110 1 0011 0011 000000000000000101",


